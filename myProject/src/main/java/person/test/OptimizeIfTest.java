package person.test;import org.apache.kafka.common.protocol.types.Field;import org.springframework.context.ApplicationContext;import org.springframework.util.StringUtils;import person.pojo.Book;import person.pojo.Comment;import person.pojo.Data;import person.pojo.ToDo;import java.io.*;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.*;import java.util.concurrent.*;import java.util.function.Consumer;import java.util.function.Predicate;public class OptimizeIfTest {    private  static String[] month = {"不通过","通过","待定"};    public static void main(String[] args) {        Map<String,String> map = new HashMap<>();        trycatchTest(map);        for (Map.Entry<String, String> stringEntry : map.entrySet()) {            System.out.println(stringEntry.getKey()+"---"+stringEntry.getValue());        }        System.out.println();    }    /**    * @Author: Zhang Shaoxuan    * @Description:  try catch 测试    * @DateTime: 2020/6/14 15:53    * @Params:    * @Return    */    public static  String  trycatchTest(   Map<String,String> map ){        try {            return    map.put("x","try");        }catch(Exception e){        }finally {            return  map.put("y","finally");        }    }    public String getResult(int code){        if(code==1) return  "通过";        if(code==0)return  "不通过";        if(code==2)return  "待定";        return month[code-1];    }    /**    * @Author: Zhang Shaoxuan    * @Description:  简单的ifelse或者switch 语句使用map可进行优化的举例    * @DateTime: 2020/6/14 11:03    * @Params:    * @Return    */    public static void mapForIf(List<String> chainName) {        int counttc5 = 0;        int counttc6 = 0;        int counttc26 = 0;        int counttc27 = 0;        int counttc7 = 0;        Map<String, Integer> map = new HashMap();        map.put("TC_5", counttc5);        map.put("TC_6", counttc6);        map.put("TC_26", counttc26);        map.put("TC_27", counttc27);        map.put("TC_7", counttc7);        for (String strings : chainName) {            int temp = map.get(strings) + 1;            map.put(strings, temp);        }        for (Map.Entry s : map.entrySet()) {            System.out.println(s.getKey()+"----"+s.getValue());        }    }    enum Status {        SECCESS(0) {            @Override            int run() {                System.out.println(this.code);                return this.getCode();            }        },        FAILURE(1) {            @Override            int run() {                System.out.println(this.code);                return this.getCode();            }        };        int code;        Status(int code1) {            this.code = code1;        }        abstract int run();        public int getCode() {            return code;        }        public void setCode(int code) {            this.code = code;        }    }    static  {    }    public static void  mapTest(Map<String,String> map ){        Map<String,String>  conditionMap = new HashMap<>();        //这里的条件map可以提前放static块中，多条件时，想办法拼接成key，然后value放不同的枚举对象名        conditionMap.put("SHGGTHL"+"QY","SHGG1T");        conditionMap.put("SZTHL"+"QY","SHHK");        conditionMap.put("BJTH"+"QY","SZ");        Strategy strategy = null;    //  这里要处理没有找到对应enum实例的情况        try {            String key = conditionMap.get(map.get("c1")+map.get("c2"));            if(!StringUtils.isEmpty(key)){                strategy  = Strategy.valueOf(key);            }        } catch (Exception e) {            e.printStackTrace();        }        String[] params = {"ddd","df"};        if(strategy!=null){            System.out.println(strategy.process(params));        }        System.out.println("end----");    }    /**    * @Author: Zhang Shaoxuan    * @Description: 定义策略的顶级接口    * @DateTime: 2020/6/14 11:37    * @Params:    * @Return    */  /*  interface Strategy{        String process(Map<String,String>map,String[] params);    }    class SSGGTStrategy implements Strategy{        @Override        public String process(Map<String, String> map, String[] params) {            return "SSGGTStrategy";        }    }    class SHStrategy implements  Strategy{        @Override        public String process(Map<String, String> map, String[] params) {            return "SH";        }    }    class  SZStrategy implements  Strategy{        @Override        public String process(Map<String, String> map, String[] params) {            return  "SZ";        }    }    class  BJStrategy implements  Strategy{        @Override        public String process(Map<String, String> map, String[] params) {            return "BJ";        }    }*/  /**  * @Author: Zhang Shaoxuan  * @Description:  if esle 优化改为enum后不用再创建多个类  * @DateTime: 2020/6/14 12:19  * @Params:  * @Return  */   enum  Strategy{       SHGGT("上海港股通"){           @Override           String process(String[] params) {               return "SHGGT";           }       },       SHHK{           @Override           String process(String[] params) {               return "SHHK";           }       },       GGT{           @Override           String process(String[] params) {               return "GGT";           }       },        SZ{            @Override            String process(String[] params) {                return "SZ";            }        };      Strategy() {      }      String description;      Strategy(String description) {          this.description = description;      }      abstract String process(String[] params);    }    enum    BO {       TABLE1{           @Override           Object getBo(String[] params, ApplicationContext ac) {               return ac.getBean("t1");           }       },        TABLE2{            @Override            Object getBo(String[] params, ApplicationContext ac) {                return ac.getBean("t2");            }        };          abstract  Object  getBo(String params[], ApplicationContext ac);    }}