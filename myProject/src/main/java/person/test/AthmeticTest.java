package person.test;import javax.naming.event.ObjectChangeListener;import java.io.*;import java.math.BigDecimal;import java.util.*;import java.util.function.Consumer;import java.util.function.Predicate;public class AthmeticTest {    public static void main(String[] args) throws Exception {    }    static  class  BST  <E extends  Comparable<E>>{        public  class  Node{            public E e;            public Node left;            public  Node right;            public Node(E e) {                this.e = e;                left = null;                right = null;            }        }        public void add(Node node,E e){            //停止递归的条件            if(e.equals(node.e)){                return;            }            if (e.compareTo(node.e)<0&&node.left==null){                node.left=new Node(e);                return;            }            if(e.compareTo(node.e)>0&&node.right==null){                node.right=new Node(e);                return;            }            if (e.compareTo(node.e)<0){               add(node.left,e);            }else{                add(node.right,e);            }        }    }   /**   * @Author: Zhang Shaoxuan   * @Description: 栈的演示   * @DateTime: 2020/5/15 19:39   * @Params:   * @Return   */static final class stack{    Object [] objs;     int capacity;     int length=0;       public stack(int length) {           this.objs = new Object[length];           this.capacity = length;       }       //resize（）        //放       public void push (Object obj) throws  Exception{           if(length<capacity) {               objs[length] = obj;               length++;           }else{               throw  new Exception("resize");           }        }        //移除对应index的        public Object remove(int index){           if (index<0||index>=length){               try {                   throw  new Exception("OutOfIndex");               } catch (Exception e) {                   e.printStackTrace();               }           };           Object object =  objs[index];           for (int i=index+1;i<length;i++){               objs[i-1]=objs[i];           }           length--;           objs[length]=null;           return object;        }        public Object pop(){           if(length==0){               return null;           }           return this.remove(length-1);        }   }}