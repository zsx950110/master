package person.test;import com.mysql.cj.conf.RuntimeProperty;import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;import com.sun.xml.bind.v2.TODO;import org.apache.poi.ss.formula.functions.T;import person.pojo.Book;import person.pojo.Comment;import person.pojo.Data;import person.pojo.ToDo;import java.io.*;import java.lang.invoke.LambdaConversionException;import java.lang.reflect.InvocationHandler;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.time.LocalDate;import java.time.format.DateTimeFormatter;import java.util.*;import java.util.concurrent.*;import java.util.concurrent.locks.ReentrantLock;import java.util.function.Consumer;import java.util.function.Predicate;public class MainTest {    static HashMap<Integer, Integer> map = new HashMap<>();    private static ThreadLocal<SimpleDateFormat> threadLocal = new ThreadLocal(){        @Override        protected SimpleDateFormat initialValue() {            return new SimpleDateFormat("yyyy/MM/dd");        }    };    //每个线程存放乐观锁的版本号    private static ThreadLocal<Integer> threadLocalVersion = new ThreadLocal<>();    /**     * @Author: Zhang Shaoxuan     * @Description: 测试split方法     * @DateTime: 2020/6/9 19:56     * @Params:     * @Return     */    public static void testSplit() {        String string = "aw,bw,cw,d,,eee,,";        if (string.trim().endsWith(",")) {            System.out.println("结尾是空");        }        String[] strings = string.split(",");        System.out.println(strings.length);        for (int i = 0; i < strings.length; i++) {            System.out.println(strings[i]);        }    }    public static void cloneTest() {        Book book = new Book();        book.setDiscount(1);        book.setId("1");        book.setPrice(23.3);        Comment comment = new Comment();        comment.setStar(1);        System.out.println("comment" + comment);        book.setComment(comment);        System.out.println("book" + book);        try {            Book book1 = book.clone();            //先克隆，再改变对象            comment.setId("dddddd");            book.setPublisher("zsxssss");            //book1中的Comment的值也发生变化            System.out.println("book1" + book1);        } catch (CloneNotSupportedException e) {            e.printStackTrace();        }    }    static  Data data = new Data();    static   Integer  test = 0;    static  void incr(){        test++;    }    static  List<Object[]> list = new ArrayList<>();    public static void main(String[] args) throws Exception {      int internal = 5;      Calendar calendar = Calendar.getInstance();      calendar.set(Calendar.SECOND,0);      int n = calendar.get(Calendar.MINUTE)%internal;      if(n<((internal+1)/2)){          calendar.add(Calendar.MINUTE,-n);      }else{          calendar.add(Calendar.MINUTE,(internal-n));      }        System.out.println(calendar.getTime());    }    //并发情况下使用SimpleDateFormat    public static  void  ConcurrentDateTest(Map<String,String> map ){     map.put("qqq","dddd");    }    public  static  void futureTest(){        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2,5,20L,TimeUnit.SECONDS,new LinkedBlockingQueue());        ToDo toDo = new ToDo();        toDo.setId("56767766");       Future<ToDo> future = threadPoolExecutor.submit(toDo);        try {            ToDo toDo1 = future.get();            System.out.println(toDo1.getId());            System.out.println("已经");        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }    }    public final static void OOM(Object[] objects) {        objects[2] = 999;    }    public static int findMax(Integer ins[]) {        int temp = ins[0];        for (int i = 1; i < ins.length; i++) {            if (ins[i] > temp) {                temp = ins[i];            }        }        return temp;    }    public static void byteCalculate() {        /**         * 异或运算 ，相同为0，不同为1  https://www.cnblogs.com/yrjns/p/11246163.html         * 2=00000010         * 3=00000011         * 1=00000001         */        System.out.println(2 ^ 3);        /**         * &与运算，都为1（真）才为1         */        System.out.println(2 & 3);        /**         * |或运算，只要一个为1就为1         */        System.out.println("|:" + (2 | 3));        /**         * 取反运算, 0->1 1->0         */        System.out.println("~:" + ~3);        /**         * << 左移3位 后面补0         * 0000 0010         * 0001 0000=16         */        System.out.println("<<:" + (2 << 3));        /**         * >> 右移3位  高位补0         * 0001 0000=16         * 0000 0010=2         */        System.out.println(">>:" + (16 >> 3));    }    /**     * @Author: Zhang Shaoxuan     * @Description: 测试for循环优化     * @DateTime: 2020/5/8 16:13     * @Params:     * @Return     */    public static void testForCircle() {        String string = "2020-09-23";        System.out.println(string.replace('-', '/'));    }    /**     * 插入排序,一个数组初始化时分成两块，第0位是有序的，后面是乱序的，     * 将乱序的从第一个开始跟有序数据中所有元素进行比对，     * 一直比对到不满足条件，然后放进去     *     * @param ins     */    public static void insertOrder(Integer[] ins) {        for (int i = 1; i < ins.length; i++) {            //每一个后对的目标元素            int target = ins[i];            //最终要插入的位置            int position = 0;            for (int j = i; j > 0; j--) {                if (target < ins[j - 1]) {                    ins[j] = ins[j - 1];                    position = j - 1;                }            }            ins[position] = target;        }       /* for (int i=1;i<ins.length;i++){            int j=i;            int target = ins[i];            for (;j>0&&target<ins[j-1];j--){                ins[j]=ins[j-1];            }            if(i!=j){                ins[j]=target;            }        }*/    }    /**     * 选择排序，从第一个开始跟其他元素比较，只要第一个比别的大就交换，第一轮过后，第一个元素就最小     * 然后从第二个开始与后面逐一比较，第二轮后第二个元素仅仅比第一个大。依次     *     * @param ins     */    public static void selectOrder(Integer[] ins) {        for (int i = 0; i < ins.length; i++) {            for (int j = i + 1; j < ins.length; j++) {                if (ins[j] < ins[i]) {                    int temp = ins[i];                    ins[i] = ins[j];                    ins[j] = temp;                }            }        }    }    /**     * 冒泡排序     *     * @param ins     */    public static void bombOrder(Integer[] ins) {        //外围是比较的次数        for (int i = 1; i < ins.length; i++) {            //如果循环了一遍后，没有交换过 说明已经排好了            boolean flag = false;            //每次排完一次，后面的数字都是有序的，因此不用管ins.length-i之后的元素            for (int j = 0; j < ins.length - i; j++) {                if (ins[j] > ins[j + 1]) {                    int temp = ins[j];                    ins[j] = ins[j + 1];                    ins[j + 1] = temp;                    flag = true;                }            }            if (!flag) {                break;            }        }    }    /**     * @Author: Zhang Shaoxuan     * @Description: 测试Lambda表达式     * @DateTime: 2020/3/21 17:44     * @Params:     * @Return     */    static void testLambda() {        //对函数式接口的实现,Lambda表达式相当于是接口的实现类        MylambdaInterface mylambdaInterface = (s) -> {            System.out.println(s);        };        List<Person> list = Arrays.asList(new Person("jone", "loyal"), new Person("lili", "john"),                new Person("jom", "jerry"), new Person("yong", "zhang"), null);        MyLambda myLambda = (s, c) -> {            if (s.startsWith(c)) {                return true;            }            return false;        };        doLambda((person) -> {            if (person.firstName.startsWith("j")) {                return true;            }            return false;        }, (person) -> {            System.out.println(person.lastName);        }, list);    }    void doaction(String param) {        //key是condition，value是functionalInterface        Map<String, Consumer<String>> map = new HashMap<>();        map.put("condition1", (s) -> {            action1(s);        });        map.put("condition2", (s) -> {            action2(s);        });        map.put("condition3", (s) -> {            action3(s);        });        map.put("condition4", (s) -> {            action3(s);        });        //....还有很多分支        map.get(param).accept(param);    }    void action1(String s) {    }    void action2(String s) {    }    void action3(String s) {    }    void action4(String s) {    }    static class Person {        private String firstName;        private String lastName;        public Person(String firstName, String lastName) {            this.firstName = firstName;            this.lastName = lastName;        }    }    public static void doLambda(Predicate<Person> mylambdaInterface, Consumer<Person> myLambda, List<Person> list) {  /*      for (Person person : list) {            if (mylambdaInterface.test(person)) {                myLambda.accept(person);            }        }*/        list.forEach(person -> {            Optional<Person> optionalPerson = Optional.ofNullable(person);            //如果不為空            optionalPerson.ifPresent(myLambda);            System.out.println("-----存在則返回，否則返回其他：" +                    optionalPerson.orElse(new Person("ww", "qq")));            //存在則返回，否则执行其他函数            optionalPerson.orElseGet(() -> {                return new Person("new", "new");            });            //连环判空并执行函数            optionalPerson.map(person2 -> {                System.out.println(person2.firstName + person2.lastName);                return person2.firstName + person2.lastName;            }).map(name -> {                System.out.println(name);                return name;            }).orElse(null);            if (mylambdaInterface.test(person)) {                myLambda.accept(person);            }        });    }    @FunctionalInterface    interface MyLambda {        boolean check(String str1, String c);    }    @FunctionalInterface    interface MylambdaInterface {        void print(String string);    }    @FunctionalInterface    interface MyFunction {        void apply(String string);    }    /**     * @Author: Zhang Shaoxuan     * @Description: 测试读取文件     * @DateTime: 2020/3/21 17:43     * @Params:     * @Return     */    static void testRead() throws IOException {        BigDecimal bigDecimal1 = new BigDecimal("2.33");        BigDecimal bigDecima2 = new BigDecimal("2.33");        int result = bigDecimal1.compareTo(bigDecima2);        System.out.println(result);        System.out.println("=======================================");        //tomcat连接jndi https://www.cnblogs.com/dgwblog/p/9669086.html        //https://www.cnblogs.com/super-yu/p/8622463.html        //https://blog.csdn.net/zbajie001/article/details/78437647        //读properties文件        //方法1，getResourceAsStream这个拿的是项目相对路径(即从项目的跟路径算起)，跟路径得看编译后的项目路径        System.out.println("获得当前项目跟路径：" + Thread.currentThread().getContextClassLoader().getResource("").getPath());        InputStream inputStream0 = Thread.currentThread().getContextClassLoader().getResourceAsStream("\\xml\\dbConfig.properties");        Properties properties0 = new Properties();        properties0.load(new InputStreamReader(inputStream0));        System.out.println(properties0.getProperty("driverClassName"));        //方法2，相对路径，即编译后要加载的文件相对于当前类的路径，可以用相对路径符号加载        InputStream inputStream = MainTest.class.getResourceAsStream("..\\..\\xml\\dbConfig.properties");        Properties properties = new Properties();        properties.load(new InputStreamReader(inputStream));        System.out.println(properties.getProperty("driverClassName"));        //方法3 通过文件流的绝对路径（物理路径）加载，可以通过以下加载绝对路径文件        System.out.println("获得当前类的类路径：" + MainTest.class.getResource("").getPath());        System.out.println("当前项目的根路径" + MainTest.class.getResource("/").getPath());        InputStream inputStream1 = new BufferedInputStream(new FileInputStream(new File(MainTest.class.getResource("/").getPath() + "xml/dbConfig.properties")));        properties.load(new InputStreamReader(inputStream1));        System.out.println(properties.getProperty("driverClassName"));        //方法4 需要资源放在系统的静态资源根路径，如resource路径        InputStream inputStream2 = ClassLoader.getSystemResourceAsStream("xml/dbConfig.properties");        properties.load(new InputStreamReader(inputStream2));        System.out.println(properties.getProperty("username"));        System.out.println("获得当前类的类路径：" + MainTest.class.getResource("").getPath());        System.out.println("当前项目的根路径" + MainTest.class.getResource("/").getPath());    }}