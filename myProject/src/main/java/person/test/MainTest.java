package person.test;import com.mysql.cj.conf.RuntimeProperty;import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;import java.io.*;import java.lang.invoke.LambdaConversionException;import java.math.BigDecimal;import java.util.*;import java.util.concurrent.TimeUnit;import java.util.function.Consumer;import java.util.function.Predicate;public class MainTest {    public static void main(String[] args) throws Exception {        Integer[] ins = new Integer[]{334,67,83,1,5,6,102};        insertOrder(ins);        for (Integer in : ins) {            System.out.print(in+" ");        }    }    public static void byteCalculate(){        /**         * 异或运算 ，相同为0，不同为1  https://www.cnblogs.com/yrjns/p/11246163.html         * 2=00000010         * 3=00000011         * 1=00000001         */        System.out.println(2^3);        /**         * &与运算，都为1（真）才为1         */        System.out.println(2&3);        /**         * |或运算，只要一个为1就为1         */        System.out.println("|:"+(2|3));        /**         * 取反运算, 0->1 1->0         */        System.out.println("~:"+~3);        /**         * << 左移3位 后面补0         * 0000 0010         * 0001 0000=16         */        System.out.println("<<:"+(2<<3));        /**         * >> 右移3位  高位补0         * 0001 0000=16         * 0000 0010=2         */        System.out.println(">>:"+(16>>3));    }    /**    * @Author: Zhang Shaoxuan    * @Description: 测试for循环优化    * @DateTime: 2020/5/8 16:13    * @Params:    * @Return    */    public static  void testForCircle(){        String string = "2020-09-23";        System.out.println(string.replace('-','/'));    }    /**     * 插入排序,一个数组初始化时分成两块，第0位是有序的，后面是乱序的，     * 将乱序的从第一个开始跟有序数据中所有元素进行比对，     * 一直比对到不满足条件，然后放进去     * @param ins     */    public static void insertOrder(Integer[] ins){        for(int i=1;i<ins.length;i++){            //每一个后对的目标元素            int target = ins[i];            //最终要插入的位置            int position=0;            for(int j=i;j>0;j--){                if (target<ins[j-1]){                    ins[j]=ins[j-1];                    position = j-1;                }            }            ins[position]=target;        }       /* for (int i=1;i<ins.length;i++){            int j=i;            int target = ins[i];            for (;j>0&&target<ins[j-1];j--){                ins[j]=ins[j-1];            }            if(i!=j){                ins[j]=target;            }        }*/    }    /**     * 选择排序，从第一个开始跟其他元素比较，只要第一个比别的大就交换，第一轮过后，第一个元素就最小     * 然后从第二个开始与后面逐一比较，第二轮后第二个元素仅仅比第一个大。依次     * @param ins     */    public static void selectOrder(Integer[] ins){        for (int i=0;i<ins.length;i++){            for (int j=i+1;j<ins.length;j++){                if(ins[j]<ins[i]){                    int temp = ins[i];                    ins[i]=ins[j];                    ins[j]=temp;                }            }        }    }    /**     * 冒泡排序     * @param ins     */    public static  void  bombOrder(Integer[] ins){        //外围是比较的次数        for (int i=1;i<ins.length;i++){            //如果循环了一遍后，没有交换过 说明已经排好了            boolean flag = false;            //每次排完一次，后面的数字都是有序的，因此不用管ins.length-i之后的元素            for (int j=0;j<ins.length-i;j++){                if(ins[j]>ins[j+1]){                    int temp = ins[j];                    ins[j]=ins[j+1];                    ins[j+1]=temp;                    flag = true;                }            }            if (!flag){                break;            }        }    }    /**     * @Author: Zhang Shaoxuan     * @Description: 测试Lambda表达式     * @DateTime: 2020/3/21 17:44     * @Params:     * @Return     */    static void testLambda() {        //对函数式接口的实现,Lambda表达式相当于是接口的实现类        MylambdaInterface mylambdaInterface = (s) -> {            System.out.println(s);        };        List<Person> list = Arrays.asList(new Person("jone", "loyal"), new Person("lili", "john"),                new Person("jom", "jerry"), new Person("yong", "zhang"),null);        MyLambda myLambda = (s, c) -> {            if (s.startsWith(c)) {                return true;            }            return  false;        };        doLambda((person)->{            if(person.firstName.startsWith("j")){                return true;            }            return false;        },(person)->{            System.out.println(person.lastName);        },list);    }     void doaction(String param){        //key是condition，value是functionalInterface        Map<String,Consumer<String>> map = new HashMap<>();        map.put("condition1",(s)->{action1(s);});        map.put("condition2",(s)->{action2(s);});        map.put("condition3",(s)->{action3(s);});        map.put("condition4",(s)->{action3(s);});        //....还有很多分支        map.get(param).accept(param);    }    void action1(String s){    }    void action2(String s){    }    void action3(String s){    }    void action4(String s){    }    static class Person {        private String firstName;        private String lastName;        public Person(String firstName, String lastName) {            this.firstName = firstName;            this.lastName = lastName;        }    }    public static void doLambda(Predicate<Person> mylambdaInterface, Consumer<Person> myLambda, List<Person> list) {  /*      for (Person person : list) {            if (mylambdaInterface.test(person)) {                myLambda.accept(person);            }        }*/        list.forEach(person -> {            Optional<Person> optionalPerson = Optional.ofNullable(person);            //如果不為空            optionalPerson.ifPresent(myLambda);            System.out.println("-----存在則返回，否則返回其他："+                    optionalPerson.orElse(new Person("ww","qq")));            //存在則返回，否则执行其他函数            optionalPerson.orElseGet(()->{                return new Person("new","new");            });            //连环判空并执行函数            optionalPerson.map(person2->{                System.out.println(person2.firstName+person2.lastName);                return  person2.firstName+person2.lastName;            }).map(name->{                System.out.println(name);                return  name;            }).orElse(null);            if (mylambdaInterface.test(person)) {                myLambda.accept(person);            }        });    }    @FunctionalInterface    interface MyLambda {        boolean check(String str1, String c);    }    @FunctionalInterface    interface MylambdaInterface {        void print(String string);    }    @FunctionalInterface    interface  MyFunction{        void  apply(String string);    }    /**     * @Author: Zhang Shaoxuan     * @Description: 测试读取文件     * @DateTime: 2020/3/21 17:43     * @Params:     * @Return     */    static void testRead() throws IOException {        BigDecimal bigDecimal1 = new BigDecimal("2.33");        BigDecimal bigDecima2 = new BigDecimal("2.33");        int result = bigDecimal1.compareTo(bigDecima2);        System.out.println(result);        System.out.println("=======================================");        //tomcat连接jndi https://www.cnblogs.com/dgwblog/p/9669086.html        //https://www.cnblogs.com/super-yu/p/8622463.html        //https://blog.csdn.net/zbajie001/article/details/78437647        //读properties文件        //方法1，getResourceAsStream这个拿的是项目相对路径(即从项目的跟路径算起)，跟路径得看编译后的项目路径        System.out.println("获得当前项目跟路径：" + Thread.currentThread().getContextClassLoader().getResource("").getPath());        InputStream inputStream0 = Thread.currentThread().getContextClassLoader().getResourceAsStream("\\xml\\dbConfig.properties");        Properties properties0 = new Properties();        properties0.load(new InputStreamReader(inputStream0));        System.out.println(properties0.getProperty("driverClassName"));        //方法2，相对路径，即编译后要加载的文件相对于当前类的路径，可以用相对路径符号加载        InputStream inputStream = MainTest.class.getResourceAsStream("..\\..\\xml\\dbConfig.properties");        Properties properties = new Properties();        properties.load(new InputStreamReader(inputStream));        System.out.println(properties.getProperty("driverClassName"));        //方法3 通过文件流的绝对路径（物理路径）加载，可以通过以下加载绝对路径文件        System.out.println("获得当前类的类路径：" + MainTest.class.getResource("").getPath());        System.out.println("当前项目的根路径" + MainTest.class.getResource("/").getPath());        InputStream inputStream1 = new BufferedInputStream(new FileInputStream(new File(MainTest.class.getResource("/").getPath() + "xml/dbConfig.properties")));        properties.load(new InputStreamReader(inputStream1));        System.out.println(properties.getProperty("driverClassName"));        //方法4 需要资源放在系统的静态资源根路径，如resource路径        InputStream inputStream2 = ClassLoader.getSystemResourceAsStream("xml/dbConfig.properties");        properties.load(new InputStreamReader(inputStream2));        System.out.println(properties.getProperty("username"));        System.out.println("获得当前类的类路径：" + MainTest.class.getResource("").getPath());        System.out.println("当前项目的根路径" + MainTest.class.getResource("/").getPath());    }}